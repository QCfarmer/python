# 踩的坑

1. 判断节点或值是否为空，小心使用if not，因为not 0也等于True，所以最好用value == None
1. 在写循环链表的时候，因为改写了find方法返回bool值，所以后面插入节点或值的时候，就出现了问题，特别注意，改变节点的next的时候尽量用链表中的节点改写，不要用输入的用作比较的值。改写了find方法后，纯粹用节点的data值去判断了，不是理论上的比较两个节点是否是同一对象。
1. 在写判断条件的时候，注意先后顺序，特别是 is None 和 is not None

# 关于数组的思考

实现起来用Python内置的list，以及list内置的insert和pop方法

但是其他语言定义的数组一般是同类型数据，Python可以存储不同类型的数据到list，所以还不知道怎么实现强制一个数组所有数据类型相同。

但正因为Python是动态类型语言，那么强制所有数据都类型相同，是不是与动态类型的设计相违背呢？

# 关于链表的思考

有很多逻辑完备和实现细节，很多书上都没讲特别细。

## 能否添加重复的节点

添加的时候修改的是Node对象的_next，所以如果添加重复的点，会在链表中形成环，打印链表的时候就会陷入死循环。

同桌说，看需求，然后进行修改。

理论上说节点指向某一块存储空间，链表的功能是可以不按连续空间存储数据。如果添加重复的节点，节点对象的_next在第一次插入后已经改变，再次插入会在链表中形成环。leetcode上就有题目是如何检测链表中的环（用快慢指针）。实现只是为了理解，大家写的链表都是添加重复节点打印会死循环的，也就是不会用到添加重复节点的。

于是我写了两个版本。一个是不能添加重复的，也就是原书和大多数网上能搜到的实现的方法。一个是通过复制节点的data值创建新Node对象，来实现可以添加重复节点到链表中，实际上只是添加的值，没有添加这个节点对象。

## 删除节点是比较节点的data值还是比较是否为同一地址的数据空间

节点指向某一存储空间，那么删除应该用a is b而不是a == b，即比较的是是否为同一地址下的同一数据，而不是单纯的data值，但网上能搜到的链表删除节点实现都是用节点的data值进行比较，例如定义：
```
a = Node(11)
b = Node(22)
c = Node(33)
```
然后将a,b,c插入了链表linked_list中，然后又定义：
```
d = Node(11)
```
此时这个链表为11->22->33。然后进行删除操作：
```
linked_list.delete_by_node(d)
```
这个链表就会删掉11，变成22->33，因为大家实现的时候都是比较的data值，d.data为11，存在于链表中，所以会删掉a节点。但理论上d节点不存在于链表中，a和d指向不同的存储空间。

所以，大家实现的时候都是为了理解链表是个啥，实现简单就行了，都没有说那么多。

## 删除值或节点是删除第一个还是所有的

原书里删除值是删除的所有值，删除节点是只删除一个节点，因为添加的时候不能实现添加重复节点，删除当然用不着咯。

所以同桌说，完全看需求。

## 总结

简单链表的实现，初始化一般要一个头节点，方法有插入和移除，就差不多了，理解了就好了。

然后其他初始化参数和方法，完全看需求。

比如说尾节点，长度，头插入，尾插入，重复节点的插入，删除一个值还是所有值，删除节点还是值，完全看需求，再进行修改。

然后同桌还说了一些操作系统的知识。删除文件只是切断指针，让操作系统无法访问，其实磁盘上那块空间的数据还在，只是访问不到，等下次写入数据的时候又会建立指针，然后覆盖写入，才算是改变了磁盘上的数据。因此操作系统显示的可用空间并不是真正的物理上磁盘上没存数据的空间，只是访问不到的空间。没用到的空间可能存了一些无意义的数据呢。有些人电脑出问题了，恢复文件，也是因为删掉的文件并不是真正从磁盘上被抹掉了，而是切断了指针地址访问，无法访问到，只要重新建立访问，就可以读取。

嗐，又是菜鸡啥也不懂的一天。

# 关于二分查找的思考

0 == False 判断为True，要用0 is False判断。

涉及到下标的递归，一般写法是写一个内部函数，传入下标。我之前都是用一个函数，判断条件非常多，复杂度会上升。

书上都是传入前后下标，步骤就少得多。

# 关于堆的思考

在做优先级队列合并多个有序数组的时候，知道实现它是为了模拟多个文件合并时内存太小的问题，但是实现的时候意识到，用数组模拟的话，是会把所有数组写进内存的，读取文件是在磁盘上读取，有读指针，但是用数组模拟，就需要保存当前数组读取到哪个元素的指针，所以开始实现的时候，是想把小顶堆改写为存有当前数组名和取出的元素组成的元组或字典。后面在想怎么判断一个数组读取结束，怎么变换到读取另一个数组呢，算了，太麻烦了，书上写的读取文件挺简单的，一页纸就写完了，但是实现起来好麻烦啊啊啊啊啊。

后面的top k问题，实现静态数组的top k没啥问题，动态数组就卡住了，因为在更新原始数组，比如说append元素的时候，一个操作要同步更新top k的小顶堆和原始数组，得用类实现，想想还是算了，理解了原理，就不写了（懒）。
